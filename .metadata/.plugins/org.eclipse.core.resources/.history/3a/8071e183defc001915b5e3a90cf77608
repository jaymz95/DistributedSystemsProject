package ie.gmit.ds;

import java.util.Scanner;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;

import com.google.protobuf.BoolValue;
import com.google.protobuf.Empty;

import io.grpc.ManagedChannel;
import io.grpc.ManagedChannelBuilder;
import io.grpc.Status;
import io.grpc.StatusRuntimeException;
import io.grpc.stub.StreamObserver;

public class PasswordClient {

	private static final Logger logger = Logger.getLogger(PasswordClient.class.getName());
	private final ManagedChannel channel;
	private final passwordServiceGrpc.passwordServiceStub async_passwordService;
	private final passwordServiceGrpc.passwordServiceBlockingStub sync_passwordService;

	public PasswordClient(String host, int port) {
		channel = ManagedChannelBuilder.forAddress(host, port).usePlaintext().build();
		sync_passwordService = passwordServiceGrpc.newBlockingStub(channel);
		async_passwordService = passwordServiceGrpc.newStub(channel);
	}

	public void shutdown() throws InterruptedException {
		channel.shutdown().awaitTermination(5, TimeUnit.SECONDS);
	}

	public String HashPassword(int userId, String password) {
		User userHash = User.newBuilder().setUserId(userId).setPassword(password).build();
		StreamObserver<User> responseObserver = new StreamObserver<User>() {

			@Override
			public void onNext(User value) {
				logger.info("User ID: " + value.getUserId() + "\n" + "Hash Password: " + value.getPassword());

			}

			@Override
			public void onError(Throwable t) {
				Status status = Status.fromThrowable(t);
				logger.info("Error: " + status.toString());

			}

			// End program System.exit(0);
			@Override
			public void onCompleted() {
				logger.info("");

			}

		};

		
		try {
			responseObserver.onNext(userHash);
			responseObserver.onCompleted();
			return responseObserver.toString();
		} catch (StatusRuntimeException ex) {
			logger.log(Level.WARNING, "RPC failed: {0}", ex.getStatus());
			return "ERROR";
		}
	}

	private BoolValue Validator(String password, String hashedPassword, String salt) {
		ValidationResponse request = ValidationResponse.newBuilder().setPassword(password).setSalt(salt)
				.setHashedPassword(hashedPassword).build();
		BoolValue result = BoolValue.newBuilder().setValue(false).build();
		result = sync_passwordService.passwordSalt(request);
		if (result.getValue()) {
			logger.info("Successfully validated password ");
		} else {
			logger.warning("Failed to validate password " + result);
		}
		return (BoolValue) result;
	}

	public static void main(String[] args) throws Exception {
		PasswordClient user = new PasswordClient("localhost", 50551);
		try {
			Scanner reader = new Scanner(System.in);
			System.out.println("Please enter your user ID: ");
			int uId = reader.nextInt();
			System.out.println("Please enter your password: ");
			String passwrd = reader.next();
			user.HashPassword(uId, passwrd);
			// Returns true if the HashPassword 
			user.Validator(passwrd, Password.hash(passwrd.toCharArray(), Password.getNextSalt()).toString(),
					Password.getNextSalt().toString());
		} catch (Exception e) {
			logger.info("Error: No Server Connection" + e.toString());
		} finally {
			// Don't stop process, keep alive to receive async response
			Thread.currentThread().join();
		}
	}

}

/*
 * asyncPasswordService.hashPass(request, res); try {
 * responseObserver.onNext(request); responseObserver.onCompleted(); return
 * responseObserver.toString(); } catch (StatusRuntimeException ex) {
 * logger.log(Level.WARNING, "RPC failed: {0}", ex.getStatus()); return "ERROR";
 * }
 * 
 * 
 * @Override public void onError(Throwable throwable) { Status status =
 * Status.fromThrowable(throwable);
 * 
 * logger.log(Level.WARNING, "RPC Error: {0}", status); }
 * 
 * @Override public void onCompleted() {
 * logger.info("Finished receiving items"); // End program System.exit(0); }
 * 
 * @Override public void onNext(HashPassword value) { logger.info("user ID = " +
 * value.getUserId() +" Pass to hash = " + value.getPassword()); }
 * 
 * @Override public void onError(Throwable t) { }
 * 
 * @Override public void onCompleted() { } };
 */
